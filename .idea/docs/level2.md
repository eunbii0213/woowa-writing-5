# GC가 필요한 이유?

C나 C++ 같은 언어에서는 개발자가 직접 메모리를 할당하고 해제해야 했습니다.
이렇게 수동으로 이루어지는 메모리 관리는 정말 번거롭고 어려운 작업입니다.
그러나 Java와 같은 언어에서는 GC가 이를 대신 처리하여 개발자는 이로부터 해방될 수 있었습니다.
GC의 내부는 어떻게 동작하길래 이런 불편함을 해소할 수 있었을까요? 지금부터 알아보겠습니다.


# GC란 무엇인가?

GC(Garbage Collection)는 프로그래밍 언어 런타임 환경에서 사용되는 메모리 관리 기법입니다.
개발자가 명시적으로 메모리 할당과 해제를 처리하는 것을 대신하여, 사용하지 않는 메모리를 자동으로 탐지하고 해제합니다.


# 장단점

### 장점:

1. 메모리 누수가 발생하지 않습니다.
2. 휴먼 에러 발생 가능성을 줄입니다.
   예를 들어, 해제된 메모리에 접근하려고 시도하거나 메모리 이중 해제하는 등의 에러를 방지합니다.

### 단점:

1. 성능 저하가 발생할 수 있습니다.터
   어떤 메모리를 해제해야 하는지 검사하고 삭제하는 과정은 결국 CPU 자원과 메모리를 필요로 합니다.
   데이터가 많을수록 이 비용은 증가하여 더 큰 단점이 될 수 있습니다.
2. 개발자는 메모리가 언제 해제되는지를 알 수 없습니다.
   JVM은 GC를 실행하기 위해 애플리케이션 실행을 일시적으로 멈춥니다.
   따라서 실시간성이 매우 강조된다면, 이런 특징이 적합하지 않을 수 있다


# jvm의 GC algorithms: Mark and Sweep

일반적으로 JVM은 Mark and Sweep과 같은 GC 알고리즘을 사용합니다.
Mark and Sweep 알고리즘은 다음과 같은 동작을 합니다.

- Root set에서 Heap 영역의 모든 객체를 스캔하여 마킹(Mark)합니다.
- Root set에서 도달할 수 없는(unreachable) 객체를 Heap 영역에서 제거합니다(스위핑, Sweep).
- Heap은 GC에 의해 관리되는 영역이므로 Mark and Sweep은 Heap 영역에서 이루어집니다.


# Mark and Sweep의 두 가지 특징

1. 의도적으로 GC를 실행해야 합니다
   JVM에는 GC를 실행해야 할 시기를 결정하는 기준이 있습니다.
   이 기준을 알기 위해서는 JVM의 Heap 영역을 살펴봐야 합니다.
2. 애플리케이션 실행과 GC 실행이 병행됩니다


# Heap

Heap은 Java 가상 머신(JVM)에서 메모리를 관리하는 데 사용되는 영역으로, 두 가지 세대(young generation, old generation)로 나누어집니다.
그런데, 왜 이렇게 영역을 두 개로 나눠야했던걸까요?
그냥 하나의 영역을 쓰면 안 되는 걸까요?
여기엔 두 가지 이유가 있습니다.

1. 할당된 객체의 대부분은 짧은 시간 내에 가비지(garbage) 상태가 되기 때문입니다.
   대부분의 객체는 짧은 지속 시간 동안만 참조됩니다.
   따라서 이러한 객체들은 빠르게 가비지 상태가 되며 메모리에서 해제될 수 있어야 합니다.
2. 오래된 객체는 젊은 객체로의 참조가 거의 없습니다
   오래된 객체에서 젊은 객체로의 참조는 매우 드물기 때문에, 젊은 세대에서 오래된 세대로의 객체 이동을 최소화할 수 있습니다.

따라서 만약 힙이 하나의 generation으로만 구성된다면, 오래된 객체까지 모두 스캔해야 하므로 효율적이지 않을 수 있습니다.
그래서 힙은 2개의 generation으로 분리되어야합니다.


# Young Generation

young generation은 새로 할당된 객체들이 위치하는 공간입니다.
young generation는 Eden 영역, Survival 0 영역, Survival 1 영역으로 구성됩니다.
Eden 영역이 가득 차게 되면 Minor GC가 실행되고, Reachable한 객체들은 Survival 0 영역으로 이동합니다.
이후 객체들은 점차적으로 Survival 1 영역으로 이동하며, 이동할 때마다 age-bit가 1만큼 증가합니다.
age-bit가 일정 값(일반적으로 15)에 도달하면 해당 객체는 오래된 객체로 간주되어 Old Generation으로 이동합니다.


# Old Generation

old generation은 세대에서 오랜 시간 동안 살아남은 객체들이 위치하는 공간입니다.
young generation과는 달리 Major GC가 발생합니다.
old generation가 가득 차게 되면 Major GC가 실행되어 불필요한 메모리를 정리합니다.

이렇게 young generation와 old generation로 나누어 가비지 컬렉션을 수행함으로써 메모리 관리의 효율성을 높일 수 있습니다.


# 자주 사용되는 GC

자주 사용되는 GC 방식 중 하나는 parallel GC입니다.
이 방식은 Java 8에서 기본적으로 사용되며, 멀티 코어 환경에서 동작합니다.
병렬 스레드를 사용하여 GC를 실행하므로 stop the world 시간이 최소화되어 빠른 GC 수행이 가능합니다.

또 다른 GC 방식은 G1 GC입니다.
이 방식은 Java 9부터 기본적으로 사용되며, 힙을 일정 크기의 영역(region)으로 분할하여 젊은 세대와 오래된 세대를 관리합니다.
이를 통해 GC 수행 시 stop the world 시간을 최소화하는 장점이 있습니다.
G1 GC는 동적으로 영역의 개수를 조정하여 최적의 성능을 제공합니다.


# 요약

GC(Garbage Collection)은 자동 메모리 관리 기법으로, 사용하지 않는 메모리를 자동으로 해제하여 메모리 누수를 방지합니다.
JVM은 Mark and Sweep 알고리즘을 사용하며, Young Generation과 Old Generation으로 나뉘어져 가비지 컬렉션을 수행합니다.
Young Generation에서는 Minor GC가 실행되어 새로 할당된 객체들을 정리하고, Old Generation에서는 Major GC가 실행되어 오래된 객체들을 정리합니다.
이를 통해 효율적인 메모리 관리가 이루어질 수 있습니다.
